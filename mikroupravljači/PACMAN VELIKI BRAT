// Pac-Man in Processing

// Grid and map
int cols = 20;
int rows = 20;
int cellSize = 30;
int[][] map;

// Pacman
int pacmanX = 1;
int pacmanY = 1;
int dirX = 0;
int dirY = 0;

// Score
int score = 0;

void setup() {
  size(600, 600);
  frameRate(10);
  initMap();
}

void draw() {
  background(0);
  drawMap();
  movePacman();
  drawPacman();
  displayScore();
}

void keyPressed() {
  if (keyCode == UP) {
    dirX = 0;
    dirY = -1;
  } else if (keyCode == DOWN) {
    dirX = 0;
    dirY = 1;
  } else if (keyCode == LEFT) {
    dirX = -1;
    dirY = 0;
  } else if (keyCode == RIGHT) {
    dirX = 1;
    dirY = 0;
  }
}

void initMap() {
  // 0 = empty, 1 = wall, 2 = dot
  map = new int[cols][rows];
  for (int x = 0; x < cols; x++) {
    for (int y = 0; y < rows; y++) {
      if (x == 0 || y == 0 || x == cols - 1 || y == rows - 1 || (x % 4 == 0 && y % 4 == 0)) {
        map[x][y] = 1; // wall
      } else {
        map[x][y] = 2; // dot
      }
    }
  }
  map[pacmanX][pacmanY] = 0; // starting position
}

void drawMap() {
  for (int x = 0; x < cols; x++) {
    for (int y = 0; y < rows; y++) {
      int cx = x * cellSize;
      int cy = y * cellSize;

      if (map[x][y] == 1) {
        fill(0, 0, 255);
        rect(cx, cy, cellSize, cellSize);
      } else if (map[x][y] == 2) {
        fill(255, 255, 0);
        ellipse(cx + cellSize / 2, cy + cellSize / 2, 6, 6);
      }
    }
  }
}

void movePacman() {
  int nextX = pacmanX + dirX;
  int nextY = pacmanY + dirY;

  if (map[nextX][nextY] != 1) { // Not a wall
    pacmanX = nextX;
    pacmanY = nextY;

    if (map[pacmanX][pacmanY] == 2) {
      map[pacmanX][pacmanY] = 0;
      score++;
    }
  }
}

void drawPacman() {
  float px = pacmanX * cellSize + cellSize / 2;
  float py = pacmanY * cellSize + cellSize / 2;
  fill(255, 255, 0);
  ellipse(px, py, cellSize - 4, cellSize - 4);
}

void displayScore() {
  fill(255);
  textSize(18);
  text("Score: " + score, 10, height - 10);
}
